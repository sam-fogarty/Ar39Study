#include "../inc/Waveforms.h"

#include <fstream>
#include <iostream>

#include "TInterpreter.h"
//#include "TString.h"
#include "TROOT.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TFile.h"
#include "TMath.h"
#include "TTree.h"
#include "TBranch.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TF1.h"

#include "gallery/Handle.h"
#include "gallery/ValidHandle.h"


void rad_analysis::Waveforms::initialize_data (const gallery::Event& ev, const std::vector<raw::RawDigit>& ard_vec,
                                               const std::vector<recob::Wire>& wire_vec, const std::vector<recob::Wire>& wire_vec2,
                                               const bool& b_noise_filter, const std::vector<double>& Par){

  int i_max, i_md; // temp variables 

  m_i_counter = 0;

  // Expand our vectors to the size needed
  adc_value = std::vector< std::vector<float> >(detector_properties.CHN, std::vector<float>(detector_properties.NTT, 0)); 
  m_region_sd = std::vector< std::vector<float> >(detector_properties.CHN, std::vector<float>(165, 0)); 
  geometry_info = std::vector< std::vector<float> >(detector_properties.CHN, std::vector<float>(9, 0));
  plane_wire_intersections = std::vector< std::vector<short> >(detector_properties.CHN, std::vector<short>(5, 0)); 
  sd_vector = std::vector<float>(detector_properties.CHN, 0);
  baseline = std::vector<float>(detector_properties.CHN, 0);
  track_channel = std::vector<bool>(detector_properties.CHN, 1); // all set to 1 for now (essentially allows track exclusion to look everywhere)
  dead_channel = std::vector<bool>(detector_properties.CHN, 0);

  std::cout << "(1) reading geometry" << std::endl; // one of many debugging messages

  //fill geom std::vectors from uboone geometry input file
  if (detector_properties.DET != 1 && detector_properties.DET != 2){ //Not for PDUNE-SP/HD
    std::ifstream geometry_input_file("geometry/MicroBooNE/ChannelWireGeometry_v2.txt"); // Header chopped off of this file; the standard one won't work.
    // Generated by geometry/MicroBooNE/GeomScript; based on WireGeometry_v2.txt
    std::ifstream collection_induction_intersection_file("geometry/MicroBooNE/plane_wire_intersections.txt");

    for (short i = 0; i < 8256; i++){
      for (char q = 0; q < 9; q++){
	geometry_input_file >> geometry_info[i][q];
      
	if (q < 5 && i >= 4800)
	  collection_induction_intersection_file >> plane_wire_intersections[i][q];
      }
    }

    geometry_input_file.close();
    collection_induction_intersection_file.close();
  }

  std::cout << "(2) read geometry successfully. Beginning baseline calculation." << std::endl;

  //if rawdigits, find baseline, maybe filter noise, and fill waveforms
  if (!data_properties.recoused){ 
    std::cout << "rawdigits selected " << std::endl;
    //std::ofstream outputFile_1("waveforms_collection.txt");
    //std::ofstream outputFile_2("waveforms_induction.txt");

    for (size_t i_ar = 0, size_allrawdigits = ard_vec.size(); i_ar != size_allrawdigits; i_ar++) { //loop through wires
      bool kcheck = false;
      bool colw = false;

      int chan_num = ard_vec.at(i_ar).Channel(); //the channels given by allrawdigits_vec might not be in order, so check the assigned channel number
      int TPC_number = channel_to_wire[chan_num][0]; 

      float total=0, totsqr=0;   
      float mean, sd, f_sum_square=0;    
      float n=0;

      m_i_sd_counter = 0;
      i_max = 0;
      for (unsigned short t = 0; t < collection_channel.size(); t++){ // Is this a collection wire?
	if (channel_to_wire[chan_num][2] == 2)
	  colw = true;
	
      }
      if (detector_properties.DET == 1 && !colw) //don't fill the induction channels for protodune yet
	continue;
      else if (detector_properties.DET == 2 && !colw) //don't fill the induction channels for protodune yet
        continue;

      m_mode_vector = std::vector<int>(8192, 0); // Normally ADCs are 12 bits, but some data products already calculate a baseline
                                                 // For consistency, baseline is re-calculated using this method,
                                                 //  but it must now account for the possibility of negative ADC values
                                                 //  hence, 2x2^12 possible values
      
      for (ULong64_t k = 0; k < static_cast<ULong64_t>(ard_vec.at(i_ar).Samples()); k++){
      //for (int k = 0; k < ard_vec.at(i_ar).Samples(); k++){
	float ADCval = ard_vec.at(i_ar).ADC(k) / data_properties.SCALE;
	//if (colw == true){
        //	outputFile_1 << ADCval << " ";
        //         }
        //else {
        //        outputFile_2 << ADCval << " ";
        //     }
        totsqr += ADCval*ADCval; //pow(ADCval,2);
	total += ADCval;
	n++;

	if (ADCval + 4096 < m_mode_vector.size()){
	  m_mode_vector.at((int)ADCval + 4096)++;
	    
	  if (m_mode_vector.at((int)ADCval + 4096) > i_max){
	    i_max = m_mode_vector.at((int)ADCval + 4096);
	    i_md = ADCval;
	  }
	}
      }
      //outputFile_1 << std::endl;
      //outputFile_2 << std::endl;
      //outputFile_1 << '\n';
      //outputFile_2 << '\n';
      mean = total/n;               // Used soon to find other statistical values
      baseline.at(chan_num) = i_md; // Baseline = Mode avg of waveform
      //std::cout << "baseline for channel " << chan_num << " = " << i_md << std::endl; 
      for (ULong64_t k = 0; k < static_cast<ULong64_t>(ard_vec.at(i_ar).Samples()); k++){
      //for (int k = 0; k < ard_vec.at(i_ar).Samples(); k++) {
	float ADCval = ard_vec.at(i_ar).ADC(k) / data_properties.SCALE;

	//Exclude outer planes for PDUNE
	if (detector_properties.DET == 0 || (detector_properties.DET == 1 && !binary_search(outer_tpc.begin(), outer_tpc.end(), TPC_number) ) || (detector_properties.DET == 2)){
	  if (k < detector_properties.NTT){
	    adc_value.at(chan_num).at(k) = (ADCval - baseline[chan_num]); // Waveform = ADC - baseline
	    }
	}
	
	f_sum_square += (ADCval - mean)*(ADCval - mean); //pow(ADCval - mean, 2);

        if (m_i_sd_counter > m_region_sd[chan_num].size()) {
        	std::cout << "Warning: m_i_sd_counter " << m_i_sd_counter << " is greater than vector size " << m_region_sd[chan_num].size() << std::endl;
	}
	m_region_sd[chan_num][m_i_sd_counter] += (ADCval - mean)*(ADCval - mean); //pow(ADCval - mean, 2);
	if (k != 0 && k % 50 == 0){
	  m_region_sd[chan_num][m_i_sd_counter] /= 50;
	  m_region_sd[chan_num][m_i_sd_counter] = sqrt(m_region_sd[chan_num][m_i_sd_counter]);
	  m_i_sd_counter++;
	  // std::cout << m_i_sd_counter << std::endl;
	}
      }

      sort(m_region_sd[chan_num].begin(), m_region_sd[chan_num].end());
      sd = sqrt(f_sum_square/(n));	// (sd)^2 = sum_i (x_i - mean(x)) / n  ***this n-1 here was an error! 
      sd_vector.at(chan_num) = sd;      // fill the vector of SD with the value sd

      //detect dead channels based on standard deviation of waveform
      if (sd < 0.3 || (detector_properties.DET == 0 && baseline.at(chan_num) > 550 && chan_num >= 4800)){// ||
	  //	  (m_region_sd[chan_num][60] + m_region_sd[chan_num][61]) / 2 > 6.0){
    
	dead_channel.at(chan_num) = 1;
	m_i_counter++;

	//exclude a couple of wires around the dead one too
	for (short w = -2; w <= 2; w++){
	  if ((chan_num + w) <= detector_properties.CHN && (chan_num + w) >= 0 && channel_to_wire[chan_num][0] == channel_to_wire[chan_num + w][0]){
	    dead_channel.at(chan_num + w) = 1;
	  }
	}
      }
    }
    //outputFile_1.close();
    //outputFile_2.close();
    std::cout << "baseline done" << std::endl;

    // f_reco_scale = 1.0;

    //median noise filter
    if (b_noise_filter){ // if noise filter flag (b_noise_filter) is true
      std::cout << "Using median noise filter" << std::endl;
      for (unsigned char TPC_number = 0; TPC_number < collection_channel.size(); TPC_number++){
	for (unsigned short wire_index = 0; wire_index < collection_channel[TPC_number].size(); wire_index += 16){
	  for (int t = 0; t < detector_properties.NTT; t++){ // loop over the whole event
	    m_median_vector.clear();

	    // find median of the ADC value at this time tick for 16 channels ahead of present channel
	    for (int i = 0; i < 16; i++){ 
	      m_median_vector.push_back(adc_value[collection_channel[TPC_number][wire_index + i]][t]);
	    }

	    sort(m_median_vector.begin(), m_median_vector.end());

	    if (m_median_vector.size() % 2 == 0)
	      i_md = (m_median_vector[(m_median_vector.size()/2) - 1] + m_median_vector[m_median_vector.size()/2])/2;
	    else
	      i_md = m_median_vector[m_median_vector.size()/2];

	    // std::cout << i_md << std::endl; 

	    // Then subtract median value at the same point for each of these channels
	    for (int q = 0; q < 16; q++){
	      adc_value[collection_channel[TPC_number][wire_index + q]][t] -= i_md;
	    }
	  }
	}
      }
    }
  } // end if not reco

  else if (data_properties.recoused) {
    std::cout << "data_properties.recoused is True" << std::endl;
    for (size_t i_ar = 0, size_allrawdigits = wire_vec.size(); i_ar != size_allrawdigits; i_ar++) {
      int chan_num = wire_vec.at(i_ar).Channel(); //the channels given by allrawdigits_vec might not be in order

      adc_value.at(chan_num) = wire_vec.at(i_ar).Signal();

      if (wire_vec.at(i_ar).Signal().size() > detector_properties.NTT){
	// std::cout << wire_vec.at(i_ar).Signal().size() << std::endl;
	adc_value.at(chan_num).erase(adc_value.at(chan_num).begin() + detector_properties.NTT, adc_value.at(chan_num).end());
      }
    }


    // Use Rawdigits to find dead channels and scale
    if (data_properties.MCCX == 8){
      std::cout << "Use Rawdigits to find dead channels and scale" << std::endl;
      for (size_t i_ar = 0, size_allrawdigits = ard_vec.size(); i_ar != size_allrawdigits; ++i_ar) {
	unsigned short n = 0;
	float x, x2, total = 0, totsqr = 0, f_sum_square = 0;

	int chan_num = ard_vec.at(i_ar).Channel();
	
	//find [x] and [x^2]
	for (ULong64_t k = 0; k < static_cast<ULong64_t>(ard_vec.at(i_ar).Samples()); k++){
	//for (int k = 0; k < ard_vec.at(i_ar).Samples(); k++){
	  float ADCval = (ard_vec.at(i_ar).ADC(k) - ard_vec.at(i_ar).GetPedestal()) / data_properties.SCALE;

	  totsqr += ADCval*ADCval; //pow(ADCval,2);
	  total += ADCval;
	  n++;
	}

	// variance = [x^2] - [x]^2
	x = total / n;
	x2 = totsqr/n;
	
	sd_vector.at(chan_num) = sqrt(abs(x2 - (x*x) /*pow(x, 2)*/));
	
	//detect dead channels based on standard deviation of waveform
	if (sd_vector.at(chan_num) < 0.3 || (ard_vec.at(chan_num).GetPedestal() > 550 && chan_num >= 4800)){
	  
	  dead_channel.at(chan_num) = 1;
	  m_i_counter++;
	  
	  for (short w = -2; w <= 2; w++){
	    if ((chan_num + w) <= detector_properties.CHN && (chan_num + w) >= 0 && channel_to_wire[chan_num][0] == channel_to_wire[chan_num + w][0]){
	      dead_channel.at(chan_num + w) = 1;
	    }
	  }
	}
      }

      f_reco_scale = 6.05724; // determined manually by comparing waveforms (probably not rigorous)
                              // scale of the threshold from adcs to the reconstructed units
    }

    else if (data_properties.MCCX == 9){
      std::cout << "data_properties.MCCX = 9" << std::endl;
      reco_product_value = std::vector< std::vector<float> >(detector_properties.CHN, std::vector<float>(detector_properties.NTT, 0)); //gauss product std::vector of waveforms for event
      
      if (!data_properties.simulated){
	for (unsigned short i = 0; i < m_bad_chan.size(); i++){
	  dead_channel[std::vector<int>(*ev.getValidHandle< std::vector<int> >("nfspl1:badchannels")).at(i)] = 1;
	}
      }
      
      else{
	for (unsigned short i = 0; i < m_bad_chan.size(); i++){
	  dead_channel[std::vector<int>(*ev.getValidHandle< std::vector<int> >("simnfspl1:badchannels")).at(i)] = 1;
	}
      }

      for (size_t i_ar = 0, size_allrawdigits = wire_vec2.size(); i_ar != size_allrawdigits; ++i_ar) {
	int chan_num = wire_vec2.at(i_ar).Channel();
	reco_product_value.at(chan_num) = wire_vec2.at(i_ar).Signal();

	if (reco_product_value.at(i_ar).size() > 6400){
	  reco_product_value.at(chan_num).erase(reco_product_value.at(chan_num).begin() + 6400, reco_product_value.at(chan_num).end());
        }
      }

      f_reco_scale = 2086.0 / 48.0; //scale of the threshold from adcs to the reconstructed units

    }
  } // end if reco
  std::cout << "before" << std::endl;  
  std::vector< std::vector<float> >().swap(m_region_sd);
  //m_region_sd.clear();
  std::cout << "after" << std::endl;
  std::cout << "Waveform Initialized" << std::endl;
}


void rad_analysis::Waveforms::Fill_Wire_Maps(){
  
  collection_channel = std::vector< std::vector<short> >(detector_properties.ntpcs);
  induction_channel_1 = std::vector< std::vector<short> >(detector_properties.ntpcs);
  induction_channel_2 = std::vector< std::vector<short> >(detector_properties.ntpcs);
  
  channel_to_wire = std::vector< std::vector<short> >(detector_properties.CHN, std::vector<short>(3));

  if (detector_properties.DET == 0){ //uboone
    inner_tpc.push_back(0);
    outer_tpc.push_back(0);

    for (int i = 0; i < detector_properties.CHN; i++){
      //Induction 1
      if (i < 2399){
	induction_channel_1[0].push_back(i);
	channel_to_wire[i][0] = 0;
	channel_to_wire[i][1] = induction_channel_1[0].size() - 1;
	channel_to_wire[i][2] = 0; //0 is the first induction plane (U)
      }

      //Induction 2
      if (i >= 2400 && i < 4800){
	induction_channel_2[0].push_back(i);
	channel_to_wire[i][0] = 0;
	channel_to_wire[i][1] = induction_channel_2[0].size() - 1;
	channel_to_wire[i][2] = 1; //1 is the second induction plane (V)
      }

      //Collection Wires
      if (i >= 4800){
	collection_channel[0].push_back(i);
	channel_to_wire[i][0] = 0;
	channel_to_wire[i][1] = collection_channel[0].size() - 1;
	channel_to_wire[i][2] = 2; //2 is the collection plane (Y)
      }
    }
  }


  else if (detector_properties.DET == 1){ //pdune
    inner_tpc.push_back(1);
    inner_tpc.push_back(2);
    inner_tpc.push_back(5);
    inner_tpc.push_back(6);
    inner_tpc.push_back(9);
    inner_tpc.push_back(10);

    outer_tpc.push_back(0);
    outer_tpc.push_back(3);
    outer_tpc.push_back(4);
    outer_tpc.push_back(7);
    outer_tpc.push_back(8);
    outer_tpc.push_back(11);

    for (int i = 0; i < detector_properties.CHN; i++){
      if (i >= 1600 && i < 2560){        //tpc 0, 1

	if (i < 2080){
	  collection_channel[0].push_back(i);
	  channel_to_wire[i][0] = 0;
	  channel_to_wire[i][1] = collection_channel[0].size() - 1;
	  channel_to_wire[i][2] = 2;
	}
	else{
	  collection_channel[1].push_back(i);
	  channel_to_wire[i][0] = 1;
	  channel_to_wire[i][1] = collection_channel[1].size() - 1;
	  channel_to_wire[i][2] = 2;
	}
      }

      else if (i >= 4160 && i < 4640){   //2
	collection_channel[2].push_back(i);
	channel_to_wire[i][0] = 2;
	channel_to_wire[i][1] = collection_channel[2].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 4640 && i < 5120){   //3
	collection_channel[3].push_back(i);
	channel_to_wire[i][0] = 3;
	channel_to_wire[i][1] = collection_channel[3].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 6720 && i < 7200){   //4
	collection_channel[4].push_back(i);
	channel_to_wire[i][0] = 4;
	channel_to_wire[i][1] = collection_channel[4].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 7200 && i < 7680){   //5
	collection_channel[5].push_back(i);
	channel_to_wire[i][0] = 5;
	channel_to_wire[i][1] = collection_channel[5].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 9280 && i < 9760){   //6
	collection_channel[6].push_back(i);
	channel_to_wire[i][0] = 6;
	channel_to_wire[i][1] = collection_channel[6].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 9760 && i < 10240){  //7
	collection_channel[7].push_back(i);
	channel_to_wire[i][0] = 7;
	channel_to_wire[i][1] = collection_channel[7].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 11840 && i < 12320){ //8
	collection_channel[8].push_back(i);
	channel_to_wire[i][0] = 8;
	channel_to_wire[i][1] = collection_channel[8].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 12320 && i < 12800){ //9
	collection_channel[9].push_back(i);
	channel_to_wire[i][0] = 9;
	channel_to_wire[i][1] = collection_channel[9].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 14400 && i < 14880){ //10
	collection_channel[10].push_back(i);
	channel_to_wire[i][0] = 10;
	channel_to_wire[i][1] = collection_channel[10].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 14880 && i < 15360){ //11
	collection_channel[11].push_back(i);
	channel_to_wire[i][0] = 11;
	channel_to_wire[i][1] = collection_channel[11].size() - 1;
	channel_to_wire[i][2] = 2;
      }
    }
  }
  else if (detector_properties.DET == 2){ //protodune-hd
    inner_tpc.push_back(1);
    inner_tpc.push_back(2);
    inner_tpc.push_back(5);
    inner_tpc.push_back(6);

    outer_tpc.push_back(0);
    outer_tpc.push_back(3);
    outer_tpc.push_back(4);
    outer_tpc.push_back(7);
    std::cout << "Using pdhd mapping" << std::endl;
    for (int i = 0; i < detector_properties.CHN; i++){
      if (i >= 1600 && i < 2560){        //tpc 0, 1

	if (i < 2080){ // APA 1 wall-side
	  collection_channel[0].push_back(i);
	  channel_to_wire[i][0] = 0;
	  channel_to_wire[i][1] = collection_channel[0].size() - 1;
	  channel_to_wire[i][2] = 2;
	}
	else{ // APA 1 cathode-side
	  collection_channel[1].push_back(i);
	  channel_to_wire[i][0] = 1;
	  channel_to_wire[i][1] = collection_channel[1].size() - 1;
	  channel_to_wire[i][2] = 2;
	}
      }

      else if (i >= 4160 && i < 4640){ // APA 3 cathode-side  //2
	collection_channel[2].push_back(i);
	channel_to_wire[i][0] = 2;
	channel_to_wire[i][1] = collection_channel[2].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 4640 && i < 5120){ // APA 3 wall-side  //3
	collection_channel[3].push_back(i);
	channel_to_wire[i][0] = 3;
	channel_to_wire[i][1] = collection_channel[3].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 6720 && i < 7200){ // APA 2 wall-side  //4
	collection_channel[4].push_back(i);
	channel_to_wire[i][0] = 4;
	channel_to_wire[i][1] = collection_channel[4].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 7200 && i < 7680){ // APA 2 cathode-side  //5
	collection_channel[5].push_back(i);
	channel_to_wire[i][0] = 5;
	channel_to_wire[i][1] = collection_channel[5].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 9280 && i < 9760){ // APA 4 cathode-side  //6
	collection_channel[6].push_back(i);
	channel_to_wire[i][0] = 6;
	channel_to_wire[i][1] = collection_channel[6].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      else if (i >= 9760 && i < 10240){ // APA 4 wall-side //7
	collection_channel[7].push_back(i);
	channel_to_wire[i][0] = 7;
	channel_to_wire[i][1] = collection_channel[7].size() - 1;
	channel_to_wire[i][2] = 2;
      }

      // if (f != -1){
      // 	channel_to_wire[i].push_back(j);
      // 	channel_to_wire[i].push_back(f);
      // 	j++;
      // 	f = -1;
      // }

      //cout << j << " --> " << i << endl; //make sure the mapping is correct
    }
  }
}
